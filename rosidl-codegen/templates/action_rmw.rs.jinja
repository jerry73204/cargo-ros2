// RMW (ROS Middleware) layer - C-compatible FFI types
// Package: {{ package_name }}
// Action: {{ action_name }}

use serde::{Deserialize, Serialize};

// Goal message
pub mod goal {
    use super::*;

    {% for constant in goal_constants %}
    pub const {{ constant.name }}: {{ constant.rust_type }} = {{ constant.value }};
    {% endfor %}

    // FFI bindings to C libraries for Goal
    #[link(name = "{{ package_name }}__rosidl_typesupport_c")]
    extern "C" {
        fn rosidl_typesupport_c__get_message_type_support_handle__{{ package_name }}__action__{{ action_name }}_Goal() -> *const std::ffi::c_void;
    }

    #[link(name = "{{ package_name }}__rosidl_generator_c")]
    #[allow(improper_ctypes)]
    extern "C" {
        fn {{ package_name }}__action__{{ action_name }}_Goal__init(msg: *mut {{ action_name }}Goal) -> bool;
        fn {{ package_name }}__action__{{ action_name }}_Goal__Sequence__init(seq: *mut rosidl_runtime_rs::Sequence<{{ action_name }}Goal>, size: usize) -> bool;
        fn {{ package_name }}__action__{{ action_name }}_Goal__Sequence__fini(seq: *mut rosidl_runtime_rs::Sequence<{{ action_name }}Goal>);
        fn {{ package_name }}__action__{{ action_name }}_Goal__Sequence__copy(in_seq: &rosidl_runtime_rs::Sequence<{{ action_name }}Goal>, out_seq: *mut rosidl_runtime_rs::Sequence<{{ action_name }}Goal>) -> bool;
    }

    #[repr(C)]
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct {{ action_name }}Goal {
        {% for field in goal_fields %}
        pub {{ field.name }}: {{ field.rust_type }},
        {% endfor %}
    }

    impl {{ action_name }}Goal {
        pub fn new() -> Self {
            Self::default()
        }
    }

    impl Default for {{ action_name }}Goal {
        fn default() -> Self {
            unsafe {
                // SAFETY: Zeroing a message structure is valid for all ROS message types
                let mut msg = std::mem::zeroed();
                // SAFETY: The init function is safe to call on a zeroed message
                if !{{ package_name }}__action__{{ action_name }}_Goal__init(&mut msg as *mut _) {
                    panic!("Call to {{ package_name }}__action__{{ action_name }}_Goal__init() failed");
                }
                msg
            }
        }
    }

    impl rosidl_runtime_rs::SequenceAlloc for {{ action_name }}Goal {
        fn sequence_init(seq: &mut rosidl_runtime_rs::Sequence<Self>, size: usize) -> bool {
            // SAFETY: The pointer is guaranteed to be valid since it comes from a mutable reference
            unsafe { {{ package_name }}__action__{{ action_name }}_Goal__Sequence__init(seq as *mut _, size) }
        }

        fn sequence_fini(seq: &mut rosidl_runtime_rs::Sequence<Self>) {
            // SAFETY: The pointer is guaranteed to be valid since it comes from a mutable reference
            unsafe { {{ package_name }}__action__{{ action_name }}_Goal__Sequence__fini(seq as *mut _) }
        }

        fn sequence_copy(in_seq: &rosidl_runtime_rs::Sequence<Self>, out_seq: &mut rosidl_runtime_rs::Sequence<Self>) -> bool {
            // SAFETY: Both pointers are guaranteed to be valid since they come from references
            unsafe { {{ package_name }}__action__{{ action_name }}_Goal__Sequence__copy(in_seq, out_seq as *mut _) }
        }
    }

    impl rosidl_runtime_rs::Message for {{ action_name }}Goal {
        type RmwMsg = Self;

        fn into_rmw_message(msg_cow: std::borrow::Cow<'_, Self>) -> std::borrow::Cow<'_, Self::RmwMsg> {
            // Identity conversion: RMW message is already in RMW format
            msg_cow
        }

        fn from_rmw_message(msg: Self::RmwMsg) -> Self {
            // Identity conversion: RMW message is already in RMW format
            msg
        }
    }

    impl rosidl_runtime_rs::RmwMessage for {{ action_name }}Goal where Self: Sized {
        const TYPE_NAME: &'static str = "{{ package_name }}/action/{{ action_name }}_Goal";

        fn get_type_support() -> *const std::ffi::c_void {
            // SAFETY: No preconditions for this function
            unsafe { rosidl_typesupport_c__get_message_type_support_handle__{{ package_name }}__action__{{ action_name }}_Goal() }
        }
    }
}

// Result message
pub mod result {
    use super::*;

    {% for constant in result_constants %}
    pub const {{ constant.name }}: {{ constant.rust_type }} = {{ constant.value }};
    {% endfor %}

    // FFI bindings to C libraries for Result
    #[link(name = "{{ package_name }}__rosidl_typesupport_c")]
    extern "C" {
        fn rosidl_typesupport_c__get_message_type_support_handle__{{ package_name }}__action__{{ action_name }}_Result() -> *const std::ffi::c_void;
    }

    #[link(name = "{{ package_name }}__rosidl_generator_c")]
    #[allow(improper_ctypes)]
    extern "C" {
        fn {{ package_name }}__action__{{ action_name }}_Result__init(msg: *mut {{ action_name }}Result) -> bool;
        fn {{ package_name }}__action__{{ action_name }}_Result__Sequence__init(seq: *mut rosidl_runtime_rs::Sequence<{{ action_name }}Result>, size: usize) -> bool;
        fn {{ package_name }}__action__{{ action_name }}_Result__Sequence__fini(seq: *mut rosidl_runtime_rs::Sequence<{{ action_name }}Result>);
        fn {{ package_name }}__action__{{ action_name }}_Result__Sequence__copy(in_seq: &rosidl_runtime_rs::Sequence<{{ action_name }}Result>, out_seq: *mut rosidl_runtime_rs::Sequence<{{ action_name }}Result>) -> bool;
    }

    #[repr(C)]
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct {{ action_name }}Result {
        {% for field in result_fields %}
        pub {{ field.name }}: {{ field.rust_type }},
        {% endfor %}
    }

    impl {{ action_name }}Result {
        pub fn new() -> Self {
            Self::default()
        }
    }

    impl Default for {{ action_name }}Result {
        fn default() -> Self {
            unsafe {
                // SAFETY: Zeroing a message structure is valid for all ROS message types
                let mut msg = std::mem::zeroed();
                // SAFETY: The init function is safe to call on a zeroed message
                if !{{ package_name }}__action__{{ action_name }}_Result__init(&mut msg as *mut _) {
                    panic!("Call to {{ package_name }}__action__{{ action_name }}_Result__init() failed");
                }
                msg
            }
        }
    }

    impl rosidl_runtime_rs::SequenceAlloc for {{ action_name }}Result {
        fn sequence_init(seq: &mut rosidl_runtime_rs::Sequence<Self>, size: usize) -> bool {
            // SAFETY: The pointer is guaranteed to be valid since it comes from a mutable reference
            unsafe { {{ package_name }}__action__{{ action_name }}_Result__Sequence__init(seq as *mut _, size) }
        }

        fn sequence_fini(seq: &mut rosidl_runtime_rs::Sequence<Self>) {
            // SAFETY: The pointer is guaranteed to be valid since it comes from a mutable reference
            unsafe { {{ package_name }}__action__{{ action_name }}_Result__Sequence__fini(seq as *mut _) }
        }

        fn sequence_copy(in_seq: &rosidl_runtime_rs::Sequence<Self>, out_seq: &mut rosidl_runtime_rs::Sequence<Self>) -> bool {
            // SAFETY: Both pointers are guaranteed to be valid since they come from references
            unsafe { {{ package_name }}__action__{{ action_name }}_Result__Sequence__copy(in_seq, out_seq as *mut _) }
        }
    }

    impl rosidl_runtime_rs::Message for {{ action_name }}Result {
        type RmwMsg = Self;

        fn into_rmw_message(msg_cow: std::borrow::Cow<'_, Self>) -> std::borrow::Cow<'_, Self::RmwMsg> {
            // Identity conversion: RMW message is already in RMW format
            msg_cow
        }

        fn from_rmw_message(msg: Self::RmwMsg) -> Self {
            // Identity conversion: RMW message is already in RMW format
            msg
        }
    }

    impl rosidl_runtime_rs::RmwMessage for {{ action_name }}Result where Self: Sized {
        const TYPE_NAME: &'static str = "{{ package_name }}/action/{{ action_name }}_Result";

        fn get_type_support() -> *const std::ffi::c_void {
            // SAFETY: No preconditions for this function
            unsafe { rosidl_typesupport_c__get_message_type_support_handle__{{ package_name }}__action__{{ action_name }}_Result() }
        }
    }
}

// Feedback message
pub mod feedback {
    use super::*;

    {% for constant in feedback_constants %}
    pub const {{ constant.name }}: {{ constant.rust_type }} = {{ constant.value }};
    {% endfor %}

    // FFI bindings to C libraries for Feedback
    #[link(name = "{{ package_name }}__rosidl_typesupport_c")]
    extern "C" {
        fn rosidl_typesupport_c__get_message_type_support_handle__{{ package_name }}__action__{{ action_name }}_Feedback() -> *const std::ffi::c_void;
    }

    #[link(name = "{{ package_name }}__rosidl_generator_c")]
    #[allow(improper_ctypes)]
    extern "C" {
        fn {{ package_name }}__action__{{ action_name }}_Feedback__init(msg: *mut {{ action_name }}Feedback) -> bool;
        fn {{ package_name }}__action__{{ action_name }}_Feedback__Sequence__init(seq: *mut rosidl_runtime_rs::Sequence<{{ action_name }}Feedback>, size: usize) -> bool;
        fn {{ package_name }}__action__{{ action_name }}_Feedback__Sequence__fini(seq: *mut rosidl_runtime_rs::Sequence<{{ action_name }}Feedback>);
        fn {{ package_name }}__action__{{ action_name }}_Feedback__Sequence__copy(in_seq: &rosidl_runtime_rs::Sequence<{{ action_name }}Feedback>, out_seq: *mut rosidl_runtime_rs::Sequence<{{ action_name }}Feedback>) -> bool;
    }

    #[repr(C)]
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct {{ action_name }}Feedback {
        {% for field in feedback_fields %}
        pub {{ field.name }}: {{ field.rust_type }},
        {% endfor %}
    }

    impl {{ action_name }}Feedback {
        pub fn new() -> Self {
            Self::default()
        }
    }

    impl Default for {{ action_name }}Feedback {
        fn default() -> Self {
            unsafe {
                // SAFETY: Zeroing a message structure is valid for all ROS message types
                let mut msg = std::mem::zeroed();
                // SAFETY: The init function is safe to call on a zeroed message
                if !{{ package_name }}__action__{{ action_name }}_Feedback__init(&mut msg as *mut _) {
                    panic!("Call to {{ package_name }}__action__{{ action_name }}_Feedback__init() failed");
                }
                msg
            }
        }
    }

    impl rosidl_runtime_rs::SequenceAlloc for {{ action_name }}Feedback {
        fn sequence_init(seq: &mut rosidl_runtime_rs::Sequence<Self>, size: usize) -> bool {
            // SAFETY: The pointer is guaranteed to be valid since it comes from a mutable reference
            unsafe { {{ package_name }}__action__{{ action_name }}_Feedback__Sequence__init(seq as *mut _, size) }
        }

        fn sequence_fini(seq: &mut rosidl_runtime_rs::Sequence<Self>) {
            // SAFETY: The pointer is guaranteed to be valid since it comes from a mutable reference
            unsafe { {{ package_name }}__action__{{ action_name }}_Feedback__Sequence__fini(seq as *mut _) }
        }

        fn sequence_copy(in_seq: &rosidl_runtime_rs::Sequence<Self>, out_seq: &mut rosidl_runtime_rs::Sequence<Self>) -> bool {
            // SAFETY: Both pointers are guaranteed to be valid since they come from references
            unsafe { {{ package_name }}__action__{{ action_name }}_Feedback__Sequence__copy(in_seq, out_seq as *mut _) }
        }
    }

    impl rosidl_runtime_rs::Message for {{ action_name }}Feedback {
        type RmwMsg = Self;

        fn into_rmw_message(msg_cow: std::borrow::Cow<'_, Self>) -> std::borrow::Cow<'_, Self::RmwMsg> {
            // Identity conversion: RMW message is already in RMW format
            msg_cow
        }

        fn from_rmw_message(msg: Self::RmwMsg) -> Self {
            // Identity conversion: RMW message is already in RMW format
            msg
        }
    }

    impl rosidl_runtime_rs::RmwMessage for {{ action_name }}Feedback where Self: Sized {
        const TYPE_NAME: &'static str = "{{ package_name }}/action/{{ action_name }}_Feedback";

        fn get_type_support() -> *const std::ffi::c_void {
            // SAFETY: No preconditions for this function
            unsafe { rosidl_typesupport_c__get_message_type_support_handle__{{ package_name }}__action__{{ action_name }}_Feedback() }
        }
    }
}

// Re-export for convenience
pub use goal::{{ action_name }}Goal;
pub use result::{{ action_name }}Result;
pub use feedback::{{ action_name }}Feedback;
